# Bloom-Filter-App
-- Implementaion of `Bloom Filter` datastructure.  
-- Showcase use of implemented bloomfilter to do lookup on a list of elements loaded from file on application startup.

## About Bloomfilter
Bloom filter is a probabilistic datastructure which gives only one piece of information, True or False based on whether the key is member of set or not. Itâ€™s an incredibly space efficient datastrucuture that is often used as a first line of defense in high performance caches. 

Bloom filter takes up very small piece of memory compared to other datastructure used for identifying member, as instead of storing each value, a bloom filter is simply an array of bits, using which it identifies the presence of the key in the filter.

There is also possibility of collision when two keys may map to same index in the bit array, this makes `Bloom Filter` a `probabilistic` datastructure where `False Positives` are possible. Which means, when bloomfilter returns 'True' for the presence of an element it may or may not be present in the set but, if it returns 'False', the element is for sure not the member of the set.

This probability of False positivity has to be deal with when using bloom filter. This chance of false positivity can be optimized based on the usecase by tuning bloomfilter at the time of initialization where, speed(fast result) is directly propertional to error rate. Which means faster the bloomfilter we make, more chances of false positive.

## Maths Behind Tuning

The major challenge is to reduce the collision in the bit array. To overcome this problem, bloom filter often use multiple hash function for each keys and hence, set multiple bit entry corresponding to each of the hash values generated by those hash function for each key.
Also, the size of Bitset should be optimal and as having small size Bitset can increase the chance of collision.

Based on the 'number of elements' going to be in bloomfilter and the 'desired false positivity', the required 'number of hash function' and 'size of BitSet' can be estimated.

n - number of elements, 

p - desired false positivity

We can determine,
```
Size of Bitset, m = (-n * logp) / (log2)^2

Number of hash functions, k = m//n (log2)
```
Using, these we can find the optimal number of Bitset size and the number of hashfunctions at the time of initializing bloomfilter.

## Hash Functions

Sometimes hashing can be time consuming. So we need to choose hash functions which takes not much time but gives effective value as it can affect performance of bloomfilter. Also, we need to generate 'k' different hash functions where 'k' depends on entry size and false probability and hence can vary for each usecase.
To make it gereric, in paper `Less Hashing, Same Performance : Building a Better Bloom Filter` it has been described how 'two hash functions' can be used to genereate 'k' different hash functions.
 ```
        gi(x) = h1(x) + ih2(x);                 
            where i = 1...k,
                  h1(x) and h2(x) are two hash functions and,
                  gi(x) is the generated hash function.
 ```       
 

